Creating a Multi Container App:
Now that we have learn about images, containers, volumes and Networking our next step is to build a multi container app that uses all above concepts.
So Our multi container app have three building blocks therefore three containers, which are follows:
i. Database: First is database for storing app data which is in our case is MongoDB. This database should have two properties, first Data must persist means data should persist either container stops or deleted. And Second Access should be limited.
ii. Backend: Second is Backend which in our case is NodeJS REST API. This is the logic of our app and it also should have two properties. First Data must persist, for our app data is logs file. And Second Live Source Code Update means all changes made in source code locally should be reflected in container. 
iii. Frontend: Third is Frontend which in our case is Reach SPA(single page app). It is the GUI of our app where user can communicate with it. The only property it should have is Live source code update.

1. Dockerizing Mongodb Container: For first step in building multi container App we create a container that is running mongoDB. To do this we simply run the following command  docker run --name mongodb --rm -d -p 27017:27017 mongo. And this will simply create our container that runs mongoDB.
2. Dockerizing the node App(Backend): Now we build image and run the container of our Node APP. To do this we first create a dockerfile in backend dirctory with all basic command which we used in previous sections. After that we build our image and run our container with following command. Docker run --name goals-backend --rm -d -p 80:80 image-name. Before doing that we also adjust our mongo url in our app.js and replace it with host.docker.internal. 
3. Dockerizing the React SPA(Frontend): Now its time to build image and run container or our Frontend React SPA. To do this first we create its docker file in its directory same as we did for Backend except here we expose port 3000 instead of 80 and here we use npm start in CMD instead of node app.js. After building our image we run our container with additional interactive and terminal flags added like docker run --name goal-frontend --rm -d -it -p 3000:3000 image-name.

NOW That we have created and run our app consisting on three containers and everything works fine but now we are optomizing our code and process of creation.
Adding Docker Network to Optimize cross Container Communication:
First we create our network i.e docker create network goals-net. Then we restart our mongo container with --network goals-net  tag added. After that we modify our code both in backend container and front container because now that we are connecting all our containers with same network we need to replace all our localhost address and host.docker.internal with the name or our container that is running mongoDB. So first we replace code in Backend app.js's code and then we rebuild our image so changes can take effect and then we re run our container and now we don't need to publish port for backend because now we are not making connection with local machine. Instead we add --network tag in our run command. After that we also modify our code in frontend app.js file and we re build our image, then we run it also with additional --network command, keep in mind we publish port 3000 so that we can visit our app.
After doing all this if we visit our application we see that it is not working properly. That is because of the logic of react app. Our backend node code is executed by server while the frontend react is executed by browser which is outside container so thats why when we replaced our code in frontend app.js the browser don't know where is mongdodb/goals is so that's why we again undo our changings in frontend app.js i.e localhost/goals and also we publish port 80 again in backend container so that browser can find it.

Adding Data Persistence to MongoDb with Volumes and Limiting Access to Our DB: 
So after adding network now we add volume to persist data and Username and Password to limit the access to our MongoDB. So to add volume we re run our mongodb container with -v tag. Here we use named volume to save our data and as we can see from the docs of mongo on dockerhub that mongo stores its data in /data/db by default so our volume tag may look like this  -v data:/data/db. After that we added our volume now we use default username and password envrionment variable of mongo to limit the access. 
Adding Bound Mount and Optomizing our Code for Nodejs:
So now that our Database's data is persistent we also want to persist our backend data like log files and also we want to add bind mount so that any change we made locally in our code reflect there. So for that we add three volume(-v) tags first for logs file like: -v logs:app/logs second for bind mount to reflect changes like: "E:/Vs-Projects/7. Multi container app:/app" 
and third to avoid node_modules from overwriting -v /app/node_modules. Now that we have added volumes now we modify our backend code so that whenever we change our code locally node server should restart and changed code should be reflected we can do this simply by using nodemon and npm. We modify our package.json file and add nodemon as devDependency and also start as service and we also our dockerfile with CMD["npm", "start"].

For this when we run our mongodb we use -e MONGO_INITDB_ROOT_USERNAME=sam -e MONGO_INITDB_ROOT_PASSWORD=mas to set the values of Username and password. After that we modify our backend code like this mongodb://sam:mas@mongodb:27017/course-goals?authSource=admin inside backticks ` instead of single quote '. After that we rebuild our backend image and start container.
Our final command for mongodb may look like this:  docker run --rm -d --name mongodb -v data:/data/db -e MONGO_INITDB_ROOT_USERNAME=sam -e MONGO_INITDB_ROOT_PASSWORD=mypass --network goals-net mongo 
and for backend: docker run --name goals-backend --rm -d -p 80:80 -e MONGODB_PASSWORD=mypass --network goals-net -v logs:/app/logs -v "E:/Vs-Projects/7. Multi container app/backend:/app" -v /app/node_modules goals:backend.

Live Source Code Updates in React Frontend:
Now that we have done with our Database and Backend now we modify our frontend. To do that we just need to modify our run coommand and add a bind mount so that all changes in local code reflect in app. The command to do this is:  docker run --rm -d -p 3000:3000 -v "E:/Vs-Projects/7. Multi container app/frontend/src:/app/src" --name goals-frontend goals:frontend. We can also add .dockerignore file to ignore what we doesn't wanna copy inside container like .git, Dockerfile and node_modules.

 